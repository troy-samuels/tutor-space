import { randomUUID } from "node:crypto";
import { z } from "zod";
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { createServiceRoleClient } from "@/lib/supabase/admin";
import { errorResponse } from "@/lib/api/error-responses";
import { generateRecap } from "@/lib/recap/generate";
import {
  getStudentRecapContext,
  buildContextBlock,
} from "@/lib/recap/context";

const GENERATE_SCHEMA = z
  .object({
    input: z.string().trim().min(1, "Input is required").max(5000, "Input too long (max 5000 chars)"),
    tutorFingerprint: z.string().trim().min(1, "Tutor fingerprint is required"),
    tutorName: z.string().trim().max(120).optional(),
    /** Optional: pass the student's fingerprint to enable adaptive recap generation */
    studentFingerprint: z.string().trim().optional(),
  })
  .strict();

async function safeParseJson(
  request: Request
): Promise<{ success: true; data: unknown } | { success: false }> {
  try {
    const data = await request.json();
    return { success: true, data };
  } catch {
    return { success: false };
  }
}

export async function POST(request: Request) {
  const requestId = randomUUID();
  const respondError = (
    message: string,
    status: number,
    code: string,
    details?: Record<string, unknown>
  ) =>
    errorResponse(message, {
      status,
      code,
      details,
      extra: { requestId },
    });

  try {
    const parsedJson = await safeParseJson(request);
    if (!parsedJson.success) {
      return respondError("Invalid JSON body", 400, "invalid_request");
    }

    const parsedBody = GENERATE_SCHEMA.safeParse(parsedJson.data);
    if (!parsedBody.success) {
      return respondError("Invalid request payload", 400, "invalid_request", {
        validation: parsedBody.error.flatten(),
      });
    }

    const { input, tutorFingerprint, tutorName, studentFingerprint } =
      parsedBody.data;

    // Try to get authenticated tutor (optional — recap works without auth)
    let tutorId: string | null = null;
    try {
      const userClient = await createClient();
      const {
        data: { user: authUser },
      } = await userClient.auth.getUser();
      if (authUser) {
        tutorId = authUser.id;
      }
    } catch {
      // Auth is optional — continue without it
    }

    const adminClient = createServiceRoleClient();
    if (!adminClient) {
      return respondError("Service unavailable", 503, "service_unavailable");
    }

    // ── SRS Context: fetch student weak spots for adaptive generation ──
    let contextBlock: string | undefined;
    if (studentFingerprint) {
      try {
        const recapContext = await getStudentRecapContext(
          studentFingerprint,
          tutorFingerprint
        );
        contextBlock = buildContextBlock(recapContext);
      } catch (err) {
        // Context is optional — continue without it
        console.warn("[Recap Generate] Context fetch failed:", err);
      }
    }

    // Generate recap via LLM (with optional SRS context)
    const { summary, exercises, generationTimeMs } = await generateRecap(
      input,
      contextBlock
    );

    // Use tutor name from input or from LLM extraction
    const displayName = tutorName ?? summary.tutorName ?? null;

    // Insert into recaps table (short_id auto-generated by trigger)
    const { data: recap, error: insertError } = await adminClient
      .from("recaps")
      .insert({
        tutor_id: tutorId,
        tutor_fingerprint: tutorFingerprint,
        tutor_display_name: displayName,
        student_name: summary.studentName,
        language: summary.language,
        level: summary.level,
        raw_input: input,
        summary: summary as unknown as Record<string, unknown>,
        exercises: exercises as unknown as Record<string, unknown>[],
        generation_model: "gpt-4o-mini",
        generation_time_ms: generationTimeMs,
      })
      .select("id, short_id, created_at")
      .single();

    if (insertError || !recap) {
      console.error("[Recap Generate] Insert failed:", insertError);
      return respondError("Failed to save recap", 500, "internal_error");
    }

    // Upsert into recap_students if we have a student name
    if (summary.studentName) {
      // Try to find existing record first for proper increment
      const { data: existingStudent } = await adminClient
        .from("recap_students")
        .select("id, recap_count")
        .eq("tutor_fingerprint", tutorFingerprint)
        .eq("student_name", summary.studentName)
        .single();

      if (existingStudent) {
        // Increment existing
        const { error: updateError } = await adminClient
          .from("recap_students")
          .update({
            tutor_id: tutorId ?? undefined,
            language: summary.language,
            level: summary.level,
            last_recap_at: new Date().toISOString(),
            recap_count: (existingStudent.recap_count ?? 0) + 1,
          })
          .eq("id", existingStudent.id);

        if (updateError) {
          console.warn("[Recap Generate] Student update warning:", updateError);
        }
      } else {
        // Insert new
        const { error: insertStudentError } = await adminClient
          .from("recap_students")
          .insert({
            tutor_id: tutorId,
            tutor_fingerprint: tutorFingerprint,
            student_name: summary.studentName,
            language: summary.language,
            level: summary.level,
            last_recap_at: new Date().toISOString(),
            recap_count: 1,
          });

        if (insertStudentError) {
          console.warn("[Recap Generate] Student insert warning:", insertStudentError);
        }
      }
    }

    return NextResponse.json({
      success: true,
      recap: {
        id: recap.id,
        shortId: recap.short_id,
        url: `/r/${recap.short_id}`,
        summary,
        exercises,
        createdAt: recap.created_at,
      },
      requestId,
    });
  } catch (error) {
    console.error("[Recap Generate] Error:", error);
    return respondError("Failed to generate recap", 500, "internal_error");
  }
}
